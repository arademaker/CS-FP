<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>The Composition of Meaning in Natural Language</title>
<!-- 2017-11-06 Seg 12:05 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="bruno cuconato" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">The Composition of Meaning in Natural Language</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Recap</a></li>
<li><a href="#sec-2">2. rules of the game</a></li>
<li><a href="#sec-3">3. quantification</a>
<ul>
<li><a href="#sec-3-1">3.1. Aristotle</a></li>
<li><a href="#sec-3-2">3.2. Frege</a></li>
<li><a href="#sec-3-3">3.3. The relational view of quantifiers</a></li>
<li><a href="#sec-3-4">3.4. Conditions on Quantifier Relations</a>
<ul>
<li><a href="#sec-3-4-1">3.4.1. EXT</a></li>
<li><a href="#sec-3-4-2">3.4.2. CONSE</a></li>
<li><a href="#sec-3-4-3">3.4.3. ISOM</a></li>
</ul>
</li>
<li><a href="#sec-3-5">3.5. numerical trees</a></li>
<li><a href="#sec-3-6">3.6. Logical Representations for Quantifiers</a></li>
<li><a href="#sec-3-7">3.7. Relational Properties</a></li>
<li><a href="#sec-3-8">3.8. Quantifiers, Automata, and Definability</a></li>
</ul>
</li>
<li><a href="#sec-4">4. The Language of Typed Logic and Its Semantics</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Recap</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>last chapter: 
<ul class="org-ul">
<li>natural language sentences -&gt; logical forms;
</li>
<li>evaluation of logical forms with respect to a model;
</li>
</ul>
</li>
<li>Haskell as a lambda calculus engine
<ul class="org-ul">
<li>disadvantage:Haskell interpreter hides the details of how
expressions of typed logic get simplified.
</li>
</ul>
</li>
<li>present chapter: composition of meaning can be carried out without
a logical form language as intermediate representation level.
<ul class="org-ul">
<li>models of predicate logic can be extended to models of typed
logic;
</li>
<li>how typed logic yields appropriate meaning representations for
the lexical items of natural language fragments
</li>
<li>provides the means for building up meanings in a compositional
way.
</li>
</ul>
</li>
<li>requirement: treat quantifiers correctly.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> rules of the game</h2>
<div class="outline-text-2" id="text-2">
<p>
natural language -&gt; predicate or typed logic presupposes:
</p>
<ul class="org-ul">
<li>that you grasp the meanings of the formulas of the representation
language;
<ul class="org-ul">
<li>can be made fully explicit, but because of this presupposed
understanding of the original message, such translations cannot
count as explications of the concept of meaning for natural
language.
</li>
</ul>
</li>
<li>that you understand the meanings of the English sentences.
</li>

<li><b>Computational semantics</b> has little or nothing to say about the
interpretation of semantic atoms. It has rather a lot to say,
however, about the process of composing complex meanings in a
systematic way out of the meanings of components.
</li>

<li id="the principle of compositionality">The meaning of an expression
is a function of the meanings of its immediate syntactic
components and their syntactic mode of composition.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> quantification</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Aristotle</h3>
<div class="outline-text-3" id="text-3-1">
<p>
An important goal in computational semantics for natural language is
to provide an account of the <i>process of drawing inferences</i> in
natural language.
</p>

<p>
Aristotle’s theory of quantification has two logical defects:
</p>
<ul class="org-ul">
<li>Quantifier combinations are not treated; only one quantifier per
sentence is allowed.
</li>
<li><i>Non-standard</i> quantifiers such as most, half of, at least five,
etc, are not covered.
</li>
<li>A minor additional flaw is the assumption of existential
presupposition.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Frege</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>first Aristotelian defects was removed by Frege: quantifiers ∀ and
∃ with their associated variables can combine with arbitrarily
complex predicate logical formulae to form new predicate logical
formulae, so a formula may contain an arbitrary number of
quantifiers.
</li>

<li>Using standard quantifiers and equality it is also possible to
express numerical constraints like At least two A are B:
</li>
</ul>
<pre class="example">
∃x∃y(x ≠ y ∧ Ax ∧ Ay ∧ Bx ∧ By).
</pre>
<ul class="org-ul">
<li>all disjunctions and conjunctions of quantifiers of the forms at
least n and at most m can be expressed in terms of standard
quantifiers and equality.
</li>

<li>To illustrate the claim that first-order logic has no difficulty
with quantifier combinations, consider the translation:
</li>
</ul>
<pre class="example">
Every prince sang a ballad.
∀x(Prince x → ∃y(Ballad y ∧ Sing x y)).
</pre>
<ul class="org-ul">
<li>but: translation does not contain phrases corresponding to the
noun phrases every prince or a ballad.
<ul class="org-ul">
<li>Given a natural language sentence and its translation into
first-order logic, it is impossible to pinpoint the
sub-expression in the translation that gives the meaning of a
particular noun phrase in the original.
</li>
<li>In the translation into first-order logic, the noun phrases have
been syntactically eliminated.
</li>
</ul>
</li>
</ul>

<pre class="example">
A ballad was sung by every prince.
∃y(Ballad y ∧ ∀x(Prince x → Sing x y))
∀x(Prince x → ∃y(Ballad y ∧ Sing x y))
</pre>

<ul class="org-ul">
<li>two translations appropriate -&gt; sentence is ambiguous.
</li>
<li>translation into FOL can be used to disambiguate natural language
sentences.
</li>
</ul>

<p>
Fregean quantifiers still have problems:
</p>
<ul class="org-ul">
<li>finding logical representation languages permitting the
preservation of noun phrases as separate constituents;
</li>
<li>finding procedures for translating from natural language to
logical representations that are not ad hoc; &#x2013; what is ad-hoc
about FOL?
</li>
<li>finding ways to treat non-standard quantifiers such as most,
preferably in a uniform framework with standard quantifiers.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> The relational view of quantifiers</h3>
<div class="outline-text-3" id="text-3-3">
<dl class="org-dl">
<dt> quantifier </dt><dd>a two-place relation on the power set of a domain
of discourse (or universe) <code>E</code> satisfying certain
requirements. (You can read <code>E</code> as mnemonic for the
set of entities, for example.) 
</dd>
<dt> power set of a set <code>E</code> </dt><dd>notation <code>P(E)</code>, is the set of all
subsets of <code>E</code>. A two-place relation on <code>P(E)</code> is a set of
pairs of subsets of <code>E</code>.
</dd>

<dt> (no term) </dt><dd>the relational view can be used to remedy the defects of both the
Aristotelian and the Fregean theory. 
</dd>
<dt> (no term) </dt><dd>a representation language with generalized quantifier expressions
(expressions denoting two-place relations between sets) and a
notation for lambda abstraction is eminently suited for the
compositional analysis of natural language sentences with
quantified noun phrases.
</dd>
</dl>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> analysis of <code>Every princess laughed.</code></caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">expression</th>
<th scope="col" class="left">translation</th>
<th scope="col" class="left">type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">every</td>
<td class="left"><b>every</b></td>
<td class="left">(e -&gt; t) -&gt; ((e -&gt; t) -&gt; t)</td>
</tr>

<tr>
<td class="left">princess</td>
<td class="left"><i>Princess</i></td>
<td class="left">(e -&gt; t)</td>
</tr>

<tr>
<td class="left">every princess</td>
<td class="left"><b>every</b> <i>Princess</i></td>
<td class="left">(e -&gt; t) -&gt; t</td>
</tr>

<tr>
<td class="left">laughed</td>
<td class="left"><i>Laugh</i></td>
<td class="left">(e -&gt; t)</td>
</tr>

<tr>
<td class="left">every princess laughed</td>
<td class="left">(<b>every</b> <i>Princess</i>) <i>Laugh</i></td>
<td class="left">t</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>DET <code>every</code> translates into an expression every denoting a
function from properties to a function from properties to truth
values.
<ul class="org-ul">
<li>More precisely, every denotes the function mapping a property P
to the characteristic function of the set of all properties
having P as a subset.
</li>
</ul>
</li>

<li>This expression yields true in case the property of being a
princess is included in the property of laughing, false
otherwise.
</li>

<li>quantifier combinations are dealt with compositionally:
</li>
</ul>
<pre class="example">
Every mermaid hummed a song.
</pre>
<ul class="org-ul">
<li>The trick is finding the right translation for the transitive verb. 
<ul class="org-ul">
<li><code>λXλy -&gt; X (λz -&gt; Hum y z)</code>, where X is a variable over noun
phrase type expressions.
</li>
</ul>
</li>
</ul>
<p class="verse">
(λXλy -&gt; X (λz -&gt; <i>Hum</i> y z))(<b>a</b> <i>Song</i>).<br  />
λy -&gt; (<b>a</b> <i>Song</i>)(λz -&gt; <i>Hum</i> y z).<br  />
</p>
<ul class="org-ul">
<li><b>a</b> denotes the function which maps every property P to (the
characteristic function of) the set of all properties having a
non-empty overlap with P. Feeding as argument to the expression
<b>every</b> <i>Mermaid</i>:
</li>
</ul>
<p class="verse">
(<b>every</b> <i>Mermaid</i>)(λy -&gt; ((<b>a</b> <i>Song</i>)(λz -&gt; <i>Hum</i> y z))).<br  />
</p>

<div class="figure">
<p><img src="./media/every-mermaid.png" alt="every-mermaid.png" />
</p>
<p><span class="figure-number">Figure 1:</span> analysis of <code>Every mermaid hummed a song.</code></p>
</div>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Conditions on Quantifier Relations</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>we view quantifiers as two-place relations on the power set of some
</li>
</ul>
<p>
domain E, satisfying certain requirements. but which ones?
</p>

<ul class="org-ul">
<li><code>All dwarfs work</code> is true in a given model if and only if the
relation of inclusion holds between the set of dwarfs in the
model and the set of workers in the model.
</li>

<li>Abstracting from the domain of discourse, we can say that
determiner interpretations (henceforth simply called determiners)
pick out binary relations on sets of individuals, on arbitrary
domains of discourse E. The notation is D<sub>E</sub>AB. 
<ul class="org-ul">
<li>We call A the restriction of the quantifier and B its body.
</li>
<li>the NP <code>all dwarfs</code> is the restriction of the determiner all,
and the VP <code>work</code> is the body.
</li>
</ul>
</li>
</ul>


<div class="figure">
<p><img src="./media/deab.png" alt="deab.png" />
</p>
<p><span class="figure-number">Figure 2:</span> Interpretation of D<sub>E</sub>AB as a relation between sets A and B</p>
</div>

<ul class="org-ul">
<li>Not all two-place relations on sets of individuals are quantifier
</li>
</ul>
<p>
relations. requirements:
</p>
<ul class="org-ul">
<li>extension (EXT);
</li>
<li>conservativity (CONSE).
</li>
</ul>
</div>

<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1"><span class="section-number-4">3.4.1</span> EXT</h4>
<div class="outline-text-4" id="text-3-4-1">
<pre class="example">
For all A, B ⊆ E ⊆ E' : DᴇAB ⇔ Dᴇ'AB.
</pre>
<p>
A relation observing EXT is stable under growth of the
universe. So, given sets A and B, only the objects in the minimal
universe A ∪ B matter.  An example is all: to determine the truth
of All dwarfs work, we only need the intersection of the set of
dwarfs and the set of workers. It does not matter at all how many
or which kind of entities are contained in the rest of the
domain. But not all natural language determiners do satisfy EXT. An
example of a determiner that does not is <i>many</i> in the sense of
<i>relatively many</i>.
</p>
</div>
</div>

<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2"><span class="section-number-4">3.4.2</span> CONSE</h4>
<div class="outline-text-4" id="text-3-4-2">
<pre class="example">
For all A, B ⊆ E: DᴇAB ⇔ DᴇA(A ∩ B).
</pre>
<p>
This property expresses that the first argument of a determiner
relation (the inter- pretation of the noun) plays a crucial role:
everything outside the extension of the first argument is
irrelevant. <i>Some</i> is an example for a conservative determiner: to
determine the truth of <code>Some dwarfs work</code>, we only need to check
whether the set of dwarfs contains workers – nothing outside the
set of dwarfs will have any effect on the truth or falsity of the
sentence.
</p>

<p>
One example that does not satisfy CONSE is only in the following
sentence.
</p>
<pre class="example">
Only dwarfs sing during work.
</pre>
<p>
This example is true in a situation where all singing workers are
dwarfs. Starting out from a situation like this, and adding some
non-dwarfs to the singing workers will it false. This shows
non-conservativity.
</p>

<p>
All is still well if it can be argued that noun phrases starting
with <i>only</i>, <i>mostly</i>, or <i>mainly</i> (two other sources of
non-conservativity) are exceptional syntactically, in the sense
that these noun phrase prefixes are not really determiners. In the
case of only, it could be argued that only dwarfs has structure
</p>
<pre class="example">
[NP [MOD only][NP dwarfs]]
</pre>
<p>
, with only not a determiner but a noun phrase modifier, just as
in:
</p>
<pre class="example">
Only Bombur sings during work.
</pre>

<p>
However this may be, separating out the determiners satisfying
CONSE and EXT is important, for the two conditions taken together
ensure that the truth of <code>D AB</code> depends only on <code>A − B</code> and <code>A ∩
    B</code>. (Thus, the combined effect of EXT and CONSE boils down to
limiting the domain of discourse relevant for the truth or falsity
of D E AB to two sets: the set of things which are A but not B,
and the set of things which are both A and B).
</p>
</div>
</div>

<div id="outline-container-sec-3-4-3" class="outline-4">
<h4 id="sec-3-4-3"><span class="section-number-4">3.4.3</span> ISOM</h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
Next, the relational perspective suggests a very natural way of
distinguishing between expressions of quantity and other
relations. Quantifier relations satisfy the following condition of
isomorphy, formulated in terms of bijections.
</p>
<pre class="example">
If f is a bijection from E to E', then DᴇAB ⇒ Dᴇ'f[A]f[B].
</pre>
<p>
Here f [A], the image of A under f , is the set of all things
which are f-values of things in A. ISOM expresses that only the
cardinalities (numbers of elements) of the sets A and B matter,
for the image of a set under a bijection is a set with the same
number of elements as the original set. If D satisfies EXT, CONS,
and ISOM, it turns out that the truth of D AB depends only on the
cardinal numbers <code>|A-B|</code> and <code>|A∩B|</code>
</p>

<p>
A quantifier simply is a relation Q satisfying EXT, CONS, and
ISOM.
</p>

<div class="figure">
<p><img src="./media/ext-conse-isom.png" alt="ext-conse-isom.png" />
</p>
<p><span class="figure-number">Figure 3:</span> The Combined Effect of EXT, CONS, ISOM.</p>
</div>

<p>
examples:
</p>
<ul class="org-ul">
<li><code>All A are B</code> is true if and only if the number of things which
are A and not B is 0.
</li>
<li><code>Some A is B</code> is true if and only if the number of things that are
both A and B is at least 1.
</li>
<li><code>Most A are B</code> is true if and only if the number of things that
are both A and B exceeds the number of things that are A and not
B.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> numerical trees</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>characterizing quantifiers Q AB according to the two numbers <code>|A
     − B|</code> and <code>|A ∩ B|</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">c7e1</span>
<span style="color: #0000ff;">treeOfNumbers'</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> [(<span style="color: #228b22;">Int</span>,<span style="color: #228b22;">Int</span>)]
<span style="color: #0000ff;">treeOfNumbers'</span> n <span style="color: #a0522d;">=</span> [(n<span style="color: #a0522d;">-</span>x,x) <span style="color: #a0522d;">|</span> x <span style="color: #a0522d;">&lt;-</span> [0<span style="color: #a0522d;">..</span>n]] <span style="color: #a0522d;">++</span> treeOfNumbers' (n<span style="color: #a0522d;">+</span>1) 

<span style="color: #0000ff;">treeOfNumbers</span> <span style="color: #a0522d;">::</span> [(<span style="color: #228b22;">Int</span>,<span style="color: #228b22;">Int</span>)]
<span style="color: #b22222;">--  </span><span style="color: #b22222;">(|A &#8722; B|, |A &#8745; B|)</span>
<span style="color: #0000ff;">treeOfNumbers</span> <span style="color: #a0522d;">=</span> treeOfNumbers' 0
</pre>
</div>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">--</span>
<span style="color: #0000ff;">numberTree</span> <span style="color: #a0522d;">::</span> [[(<span style="color: #228b22;">Int</span>,<span style="color: #228b22;">Int</span>)]]
<span style="color: #0000ff;">numberTree</span> <span style="color: #a0522d;">=</span> [[(n<span style="color: #a0522d;">-</span>x,x) <span style="color: #a0522d;">|</span> x <span style="color: #a0522d;">&lt;-</span> [0<span style="color: #a0522d;">..</span>n]] <span style="color: #a0522d;">|</span> n <span style="color: #a0522d;">&lt;-</span> [0<span style="color: #a0522d;">..</span>]]

<span style="color: #0000ff;">putTree</span> <span style="color: #a0522d;">::</span> [[(<span style="color: #228b22;">Int</span>, <span style="color: #228b22;">Int</span>)]] <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">IO</span> <span style="color: #228b22;">()</span>
<span style="color: #0000ff;">putTree</span> <span style="color: #a0522d;">=</span> mapM_ print
<span style="color: #b22222;">--</span><span style="color: #b22222;">--</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Logical Representations for Quantifiers</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>The pairs of cardinals that characterize a quantifier Q AB can be
used for representation purposes.
</li>
<li>Every quantifier is defined by means of an arithmetical
expression in two variables m and n, where m is the number of
elements in A − B, n the number of elements in A ∩ B. Logical
forms for quantified expressions can exploit this fact (<code>↦</code> ::
<i>translates as</i>):
</li>
<li>at least two ↦ λm,n -&gt; n ≥ 2.
</li>
<li>all ↦ λm,n -&gt; m = 0.
</li>
<li>no ↦ λm,n -&gt; n = 0.
</li>

<li>Logical operations on quantifiers can now be handled
compositionally:
<ul class="org-ul">
<li>If <i>Q ↦ E</i>, then <i>not Q ↦ λm,n -&gt; ¬ (Emn)</i>.
</li>
<li>If <i>Q<sub>1</sub> ↦ E<sub>1</sub></i> and <i>Q<sub>2</sub> ↦ E<sub>2</sub></i> , then <i>Q<sub>1</sub></i> and <i>Q<sub>2</sub> ↦ λm,n -&gt;
((E<sub>1</sub> mn) ∧ (E<sub>2</sub> mn))</i> and <i>[Q<sub>1</sub> or Q<sub>2</sub> ] ↦ λm,n -&gt; ((E<sub>1</sub> mn) ∨
(E<sub>2</sub> mn))</i>.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> Relational Properties</h3>
<div class="outline-text-3" id="text-3-7">
<ul class="org-ul">
<li>quantifiers are relations, so we can study their relational
properties and the way in which these properties are reflected in
the tree patterns.
</li>
<li>For example, a quantifier Q is reflexive if and only if <code>∀X Q
     XX</code>.
<ul class="org-ul">
<li>E.g. the quantifiers all and some are reflexive, the
quantifiers no and not all are not.
</li>
</ul>
</li>

<li>If Q is reflexive, what will its tree pattern be like?
</li>
<li>Can it be shown that every quantifier with this tree pattern is
reflexive?
</li>
<li>If some quantifier Q has a tree pattern with an outer north east
diagonal consisting of minus signs, which relational property of
Q does this reflect?
</li>

<li>A relational property with linguistic interest is symmetry.
<ul class="org-ul">
<li>A quantifier Q is symmetric if and only if <code>∀X∀Y Q XY ⇔ Q Y X</code>.
</li>
<li>symmetric quantifiers are the class of quantifiers which can
occur at the Q position in <i>there</i>-existential sentences
(sentences of the form <code>There are Q</code>, e.g., <code>There are
       some...</code>).
</li>
<li>its tree pattern is &#x2026;
</li>
</ul>
</li>

<li>Another example of a relational property of quantifiers with
linguistic interest is upward right-monotonicity in the second
argument place:
<dl class="org-dl">
<dt> MON↑ </dt><dd>If Q AB and B ⊆ B', then Q AB'.
</dd>
<dt> (no term) </dt><dd>This means that the truth or falsity of Q AB does not change if
the set B is extended. Examples of quantifiers that upward
right-monotone are all, some, and at least five.
</dd>
<dt> (no term) </dt><dd>its tree pattern is &#x2026;
</dd>
</dl>
</li>

<li>A quantifier relation is downward right-monotone in the second
argument if the following holds:
<dl class="org-dl">
<dt> MON↓ </dt><dd>If Q AB and B' ⊆ B, then Q AB'.
</dd>
<dt> (no term) </dt><dd>I.e. the truth or falsity of Q AB is not affected by a
reduction of the set B. Examples are not all and no.
</dd>
<dt> (no term) </dt><dd>its tree pattern is &#x2026;
</dd>
</dl>
</li>

<li>An example for a quantifier that satisfies neither MON↑ nor MON↓
is an even number of.
</li>

<li id="↑MON">If Q AB and A ⊆ A', then Q A' B.
</li>
<li id="↓MON">If Q AB and A' ⊆ A, then Q A' B.
</li>
<li>Examples of ↑MON determiners are some and not all. All and no are
↓MON determiners.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> Quantifiers, <a href="http://www.inf.ed.ac.uk/teaching/courses/inf1/cl/notes/Comp1.pdf">Automata</a>, and Definability</h3>
<div class="outline-text-3" id="text-3-8">
<ul class="org-ul">
<li>Quantifiers correspond to automata:
<ul class="org-ul">
<li>Σ: binary alphabet {0, 1}: a string s with m zeros and n ones
in it is accepted if and only if position (m, n) in the
numerical tree if the quantifier has a +.
</li>
<li>To give an example, the quantifier all corresponds to the
regular language <code>1*</code> (the set of all strings consisting of
just 1s).
</li>
</ul>
</li>
</ul>

<blockquote>
<dl class="org-dl">
<dt> c7e11 </dt><dd>Construct finite state machines for computing:
<ul class="org-ul">
<li><i>at least two</i>
</li>
</ul>
</dd>
</dl>

<div class="figure">
<p><img src="./media/at-least-2.png" alt="at-least-2.png" />
</p>
</div>

<ul class="org-ul">
<li><i>at most five</i>
</li>
</ul>

<div class="figure">
<p><img src="./media/at-most-five.png" alt="at-most-five.png" />
</p>
</div>

<ul class="org-ul">
<li><i>between three and seven</i>
</li>
</ul>

<div class="figure">
<p><img src="./media/bet-3-and-7.png" alt="bet-3-and-7.png" />
</p>
</div>
</blockquote>

<dl class="org-dl">
<dt> permutation invariant FSM </dt><dd>if reading a string s will get the
machine from state p to state q, then reading any permutation of
s will also get the machine from state p to state q.
</dd>

<dt> acyclic FSM </dt><dd>if the machine does never return to a given state
once it has left that state (in other words: 1-cycles
are allowed, but all other cycles are out). 
<ul class="org-ul">
<li>An example of a quantifier that can be computed by a cyclic finite
state machine but not by an acyclic one is <i>an even number of</i>.
</li>
</ul>
</dd>

<dt> first-order definable quantifier </dt><dd>if it is definable in terms of
the Fregean quantifiers ∀ and ∃, equality, and the two predicates
for the restriction and the body of the quantifier. 
<ul class="org-ul">
<li>The question of first-order definability is relevant for the
semantics of natural language, because the suitability of logical
representation languages for given natural language fragments
depends on it.
</li>
</ul>
</dd>
</dl>

<blockquote>
<p>
The first-order definable quantifiers are exactly those that can be
computed by an acyclic permutation-invariant finite state machine
</p>
</blockquote>

<ul class="org-ul">
<li>therefore, <i>an even number of</i> is not first-order definable (a
cyclic automaton is needed for its computation);
</li>
<li>nor are quantifiers like half and most, which cannot be computed
on a finite state machine at all (a memory stack is needed to
‘remember’ the numbers of elements in A − B and A ∩ B).
</li>
</ul>

<blockquote>
<p>

</p>

<dl class="org-dl">
<dt> c7e12 </dt><dd>The automata perspective can be exploited to give an
account of semi-quantifiers involving ordinals:

<ul class="org-ul">
<li><i>Every tenth page of a fairy tale is boring.</i>
</li>
</ul>
</dd>
</dl>

<div class="figure">
<p><img src="./media/every-tenth.png" alt="every-tenth.png" />
</p>
</div>

<ul class="org-ul">
<li><i>The first ten pages of a fairy tale are boring.</i>
</li>
</ul>

<div class="figure">
<p><img src="./media/first-ten.png" alt="first-ten.png" />
</p>
</div>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> The Language of Typed Logic and Its Semantics</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>assumption: we have constants and variables available for all
types in the type hierarchy. 
</li>
</ul>
<p>
Then the language of typed logic over these is defined as follows:
</p>
<p class="verse">
type ::= e | t | (type -&gt; type)<br  />
expression ::= constant<sub>type</sub><br  />
&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;| variable<sub>type</sub><br  />
&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;| (\ variable<sub>type</sub><sub>1</sub> -&gt; expression<sub>type</sub><sub>2</sub>)<sub>(type<sub>1</sub> -&gt; type<sub>2</sub>)</sub><br  />
&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;| (expression<sub>type<sub>1</sub> -&gt; type<sub>2</sub></sub> expression<sub>type</sub><sub>1</sub>)<sub>type</sub><sub>2</sub><br  />
</p>

<blockquote>
<dl class="org-dl">
<dt> c7e13 </dt><dd>Assume constant A has type e -&gt; t and constant B has type 
</dd>
</dl>
<p>
(e -&gt; t) -&gt; t.  Variable x has type e, variable Y has type e -&gt;
t. Which of the following expressions are well-typed?
</p>
<dl class="org-dl">
<dt> (\x -&gt; (A x)) </dt><dd>yes: <code>e -&gt; t</code>.
</dd>
<dt> (B (\x -&gt; (A x))) </dt><dd>yes: <code>t</code>.
</dd>
<dt> (\Y -&gt; (Y (\x -&gt; (A x)))) </dt><dd>yes: <code>((e -&gt; t) -&gt; x) -&gt; x</code>, where
x is some type.
</dd>
<dt> (\Y -&gt; (B Y)) </dt><dd>yes: <code>(e -&gt; t) -&gt; t</code>.
</dd>
</dl>
</blockquote>

<dl class="org-dl">
<dt> A model M for typed logic </dt><dd>consists of a domain D e together
with an interpretation function I which maps every constant of
the language to a function of the appropriate type in the
domain hierarchy based on D<sub>e</sub>. A variable assignment g for
typed logic maps every variable of the language to a function
of the appropriate type in the domain hierarchy. The semantics
for the language is given by defining a function []<sup>M</sup><sub>g</sub> which
maps every expression of the language to a function of the
appropriate type.

<ul class="org-ul">
<li>[ <b>constant</b> ]<sup>M</sup><sub>g</sub> = I(<b>constant</b>)
</li>
<li>[ <b>variable</b> ]<sup>M</sup><sub>g</sub> = g(<b>variable</b>)
</li>
<li>[(\ v<sub>t1</sub> -&gt; E<sub>t2</sub>)]<sup>Mg</sup> = <i>h</i>, where h:D<sub>t1</sub> -&gt; D<sub>t2</sub> is the
function given by \d -&gt; [E]<sup>M</sup><sub>g[v:=d]</sub>
</li>
<li>[(E<sub>1</sub> E<sub>2</sub>)]<sup>M</sup><sub>g</sub> = [E<sub>1</sub>]<sup>M</sup><sub>g</sub>([E<sub>2</sub>]<sup>M</sup><sub>g</sub>)
</li>
</ul>
</dd>

<dt> (no term) </dt><dd>logical constants of predicate logic can be viewed as constants of
typed logic, as follows: ¬ is a constant of type t → t with the
following interpretation.
<ul class="org-ul">
<li>[¬] = h, where h is the function in t → t which maps 0 to 1 and
vice versa;
</li>
<li>∧ and ∨ are constants of type t → t → t with the following
interpretations:
</li>
<li>[∧] = h, where h is the function in t → t → t which maps 1 to
{(1, 1), (0, 0)} and 0 to {(1, 0), (0, 0)};
</li>
<li>[∨] = h, where h is the function in t → t → t which maps 1 to
{(1, 1), (0, 1)} and 0 to {(1, 1), (0, 0)};
</li>
</ul>
</dd>
</dl>
<p>
Note that {(1, 1), (0, 0)} is the identity function on {0, 1}.
</p>

<dl class="org-dl">
<dt> c7e15 </dt><dd>Give the interpretation of the material implication
constant <code>-&gt;</code> in typed logic.
</dd>
</dl>
<p>
<code>-&gt;</code> has type T = <code>t -&gt; t -&gt; t</code>, and interpretation function [-&gt;] =
h, where h is the function in T which maps 1 to {(1,1), (0,0)} and 0
to {(1,1), (0,1)};
</p>

<dl class="org-dl">
<dt> c7e16 </dt><dd>Give the interpretation of the material equivalence
constant <code>&lt;-&gt;</code> in typed logic.
</dd>
</dl>
<p>
<code>&lt;-&gt;</code> has type T = <code>t -&gt; t -&gt; t</code>, and interpretation function [&lt;-&gt;]
= h, where h is the function in T which maps 1 to {(1,1), (0,0)} and
0 to {(1,0), (0,1)};
</p>

<ul class="org-ul">
<li>The quantifiers ∃ and ∀ are constants of type (e → t) → t, with
the following interpretations:
<ul class="org-ul">
<li>[∀] = h, where h is the function in (e → t) → t which maps the
function that characterizes D<sub>e</sub> to 1 and every other
characteristic function to 0;
</li>
<li>[∃], where h is the function in (e → t) → t which maps the
function that characterizes ∅ to 0 and every other
characteristic function to 1.
</li>
</ul>
</li>

<li>It is possible to add constants for quantification over different
types.
<ul class="org-ul">
<li>E.g. to express second-order quantification (i.e. quantification
over properties of things), one would need quantifier constants
of type ((e → t) → t) → t.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2017-11-03</p>
<p class="author">Author: bruno cuconato</p>
<p class="date">Created: 2017-11-06 Seg 12:05</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
